<!doctype html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ASVAB 模拟题（整套）</title>
  <style>
    body{background:#0b1220;color:#e5e7eb;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial}
    .wrap{max-width:980px;margin:0 auto;padding:24px}
    .card{background:#0f172a80;border:1px solid #1f2937;border-radius:14px;padding:16px;margin:12px 0}
    h1{font-size:40px;margin:28px 0}
    .small{opacity:.8;font-size:14px}
    a,select,button,input{font:inherit}
    .btn{background:#1f2937;border:1px solid #374151;color:#e5e7eb;padding:.65rem 1rem;border-radius:.8rem}
    .btn-primary{background:linear-gradient(135deg,#06b6d4,#3b82f6);color:#fff;border:0;padding:.7rem 1.2rem;border-radius:.8rem;box-shadow:0 6px 20px rgba(59,130,246,.25),0 2px 6px rgba(6,182,212,.35);transition:transform .08s ease,filter .2s ease;cursor:pointer}
    .btn-primary:hover{transform:translateY(-1px);filter:brightness(1.05)}
    .btn-primary:active{transform:translateY(0);filter:brightness(.98)}
    .btn-primary[disabled]{opacity:.65;cursor:not-allowed;box-shadow:none}
    .btn-primary.is-loading{position:relative;color:transparent}
    .btn-primary.is-loading::after{content:"";position:absolute;inset:0;margin:auto;width:16px;height:16px;border-radius:50%;border:2px solid rgba(255,255,255,.6);border-top-color:transparent;animation:spin .8s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <header class="wrap" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
    <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap;">
      <div style="font-weight:700">ASVAB 学习指南</div>
      <a href="index.html" class="small" style="color:#93c5fd;text-decoration:none;">← 返回首页</a>
    </div>
    <div style="display:flex;gap:16px;align-items:center;flex-wrap:wrap;">
      <div class="small" id="timer" style="color:#facc15;"></div>
      <div class="small" id="whoami"></div>
    </div>
  </header>

  <main class="wrap">
    <h1>ASVAB 模拟题 </h1>

    <div class="card" style="display:flex;gap:12px;flex-wrap:wrap;align-items:center">
      <label>科目：
        <select id="module">
          <option value="AR">AR KP</option>
          <option value="MK">MK 数学知识</option>
          <option value="WK">WK / PC 词汇与阅读</option>
          <option value="GS">GS 自然科学</option>
        </select>
      </label>

      <button id="load" class="btn-primary" onclick="onLoadClick()">加载整套</button>

      <span id="currentSet" class="small" style="margin-left:auto"></span>
      <button id="logout" class="btn">退出登录</button>
    </div>

    <div id="status" class="wrap small" style="padding-top:0;color:#93c5fd"></div>

    <div id="quiz"></div>

    <div class="card" id="actions" style="display:none;gap:12px;align-items:center;flex-wrap:wrap">
      <button id="submit" class="btn-primary">提交答案</button>
      <button id="toggleWrong" class="btn-primary" style="display:none">只看错题</button>
      <button id="exportWrong" class="btn-primary" style="display:none">导出错题 PDF</button>
      <button id="exportFull" class="btn-primary" style="display:none">导出整套 PDF</button>
      <button id="viewHistory" class="btn">查看成绩记录</button>
      <button id="scrollTop" class="btn">回到顶部</button>
      <button id="scrollBottom" class="btn">跳到底部</button>
    </div>

    <div class="card" id="result" style="display:none"></div>
    <div class="card" id="historyPanel" style="display:none;max-width:100%;overflow:auto"></div>
  </main>

  <!-- 全部逻辑放在一个模块脚本里，避免作用域问题 -->
  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const PDF_FONT_NAME = 'NotoSansCJKsc';
    const PDF_FONT_FILE = 'NotoSansSC-Regular.otf';
    const PDF_FONT_URL = 'https://cdn.jsdelivr.net/npm/@l-hammer/noto-sans-sc@0.0.3/NotoSansSC-Regular.otf';
    const PDF_FONT_ENCODING = 'Identity-H';

    let cachedFontData = null;
    let fontLoadingPromise = null;

    const arrayBufferToBase64 = (buffer) => {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 0x8000;
      let binary = '';
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    };

    const escapeHtml = (value) =>
      String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');


    const ensurePdfFont = async (doc) => {
      const fontList = doc.getFontList?.() || {};
      if (fontList[PDF_FONT_NAME]) {
        doc.setFont(PDF_FONT_NAME, 'normal', PDF_FONT_ENCODING);
        return;
      }

      if (!cachedFontData) {
        if (!fontLoadingPromise) {
          fontLoadingPromise = fetch(PDF_FONT_URL, { cache: 'force-cache' })
            .then((resp) => {
              if (!resp.ok) {
                throw new Error(`字体文件下载失败：HTTP ${resp.status}`);
              }
              return resp.arrayBuffer();
            })
            .then((buffer) => arrayBufferToBase64(buffer))
            .catch((err) => {
              cachedFontData = null;
              fontLoadingPromise = null;
              throw err;
            });
        }
        cachedFontData = await fontLoadingPromise;
        fontLoadingPromise = null;
      }

      if (!cachedFontData) {
        throw new Error('未能获取字体数据');
      }

      doc.addFileToVFS(PDF_FONT_FILE, cachedFontData);
      doc.addFont(PDF_FONT_FILE, PDF_FONT_NAME, 'normal', PDF_FONT_ENCODING);
      doc.setFont(PDF_FONT_NAME, 'normal', PDF_FONT_ENCODING);
    };

    const supabase = createClient(
      "https://tsximmhtxysoeabxwlkv.supabase.co",
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRzeGltbWh0eHlzb2VhYnh3bGt2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA4MDA2MTcsImV4cCI6MjA3NjM3NjYxN30.PQ0Fldv-vl4o_LH9niy2IbJwhcrCPbsaEM7sLEgXf8U"
    );

    async function init() {
      const { jsPDF } = await import("https://cdn.jsdelivr.net/npm/jspdf@2.5.1/+esm");

      const createPdfContext = async () => {
        const doc = new jsPDF({ unit: 'pt', format: 'a4' });
        doc.setTextColor(20);

        const margin = 48;
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const printableWidth = pageWidth - margin * 2;
        const pxPerPt = 96 / 72;
        let y = margin;
        let fontReady = true;
        let fontError = null;

        const fallbackCanvas = document.createElement('canvas');
        const fallbackCtx = fallbackCanvas.getContext && fallbackCanvas.getContext('2d');

        try {
          await ensurePdfFont(doc);
        } catch (err) {
          fontReady = false;
          fontError = err;
          doc.setFont('helvetica', 'normal');
        }

        const ensureSpace = (needed) => {
          if (y + needed > pageHeight - margin) {
            doc.addPage();
            y = margin;
          }
        };

        const wrapFallbackText = (text, fontSize) => {
          if (!fallbackCtx) return [text];
          fallbackCtx.font = `${fontSize}px sans-serif`;
          const maxWidthPx = printableWidth * pxPerPt;
          const lines = [];
          let current = '';
          let lastBreak = -1;

          for (let i = 0; i < text.length; i++) {
            const ch = text[i];
            const tentative = current + ch;
            const width = fallbackCtx.measureText(tentative).width;
            const breakable = /\s/.test(ch) || /[，。,、；；！？]/.test(ch);

            if (width > maxWidthPx && current) {
              if (lastBreak > 0) {
                const line = current.slice(0, lastBreak);
                lines.push(line.trimEnd());
                current = current.slice(lastBreak).trimStart() + ch;
              } else {
                lines.push(current.trimEnd());
                current = ch;
              }
              lastBreak = -1;
              continue;
            }

            current = tentative;
            if (breakable) {
              lastBreak = current.length;
            }
          }

          if (current) {
            lines.push(current.trimEnd());
          }

          return lines.length ? lines : [''];
        };

        const renderLineAsImage = (line, fontSize) => {
          if (!fallbackCtx) {
            return { dataUrl: '', widthPt: printableWidth, heightPt: fontSize * 1.45 };
          }
          fallbackCtx.font = `${fontSize}px sans-serif`;
          const ratio = window.devicePixelRatio || 1;
          const textWidthPx = Math.max(1, fallbackCtx.measureText(line).width);
          const textHeightPx = fontSize * 1.35;
          fallbackCanvas.width = Math.ceil((textWidthPx + 6) * ratio);
          fallbackCanvas.height = Math.ceil((textHeightPx + 6) * ratio);

          fallbackCtx.save();
          fallbackCtx.scale(ratio, ratio);
          fallbackCtx.clearRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
          fallbackCtx.font = `${fontSize}px sans-serif`;
          fallbackCtx.fillStyle = '#141414';
          fallbackCtx.textBaseline = 'top';
          fallbackCtx.fillText(line, 3, 3);
          fallbackCtx.restore();

          return {
            dataUrl: fallbackCanvas.toDataURL('image/png'),
            widthPt: (textWidthPx + 6) / pxPerPt,
            heightPt: (textHeightPx + 6) / pxPerPt
          };
        };

        const addParagraph = (text, options = {}) => {
          const { fontSize = 12, gap = 18 } = options;
          const effectiveGap = Math.max(gap, fontSize * 1.45);
          const content = String(text ?? '');
          const pieces = content.split(/\r?\n/);

          pieces.forEach((part, partIdx) => {
            const lines = fontReady
              ? (() => {
                  doc.setFontSize(fontSize);
                  doc.setFont(PDF_FONT_NAME, 'normal', PDF_FONT_ENCODING);
                  return doc.splitTextToSize(part, printableWidth);
                })()
              : wrapFallbackText(part, fontSize);

            const outputLines = lines.length ? lines : [''];

            outputLines.forEach((line) => {
              if (fontReady) {
                ensureSpace(effectiveGap);
                doc.setFontSize(fontSize);
                doc.setFont(PDF_FONT_NAME, 'normal', PDF_FONT_ENCODING);
                doc.text(line, margin, y + fontSize * 0.85);
                y += effectiveGap;
              } else {
                const { dataUrl, widthPt, heightPt } = renderLineAsImage(line, fontSize);
                const lineSpacing = Math.max(effectiveGap, heightPt);
                ensureSpace(lineSpacing);
                if (dataUrl) {
                  doc.addImage(dataUrl, 'PNG', margin, y, widthPt, heightPt);
                }
                y += lineSpacing;
              }
            });

            if (partIdx < pieces.length - 1) {
              ensureSpace(effectiveGap);
              y += effectiveGap;
            }
          });
        };

        const addSpacer = (gap = 12) => {
          const amount = Math.max(0, gap);
          if (!amount) return;
          ensureSpace(amount);
          y += amount;
        };

        return {
          doc,
          addParagraph,
          addSpacer,
          ensureSpace,
          save: (fileName) => doc.save(fileName),
          isFontReady: () => fontReady,
          getFontError: () => fontError,
          margin,
          printableWidth
        };
      };

      const notifyFontFallback = (err) => {
        if (!err) return;
        console.error('PDF 字体加载失败：', err);
        alert(
          err?.message
            ? `字体加载失败：${err.message}\n将使用备用方案导出，内容会以图片嵌入，仍可正常阅读。`
            : '字体加载失败，将使用备用方案导出，内容会以图片嵌入，仍可正常阅读。'
        );
      };

      const { data: sessionData } = await supabase.auth.getSession();
      const session = sessionData.session;
      if (!session) {
        location.href = "auth.html";
        throw new Error("Not signed in");
      }
      const user = session.user;
      let studentName = "";

      const setStatus = (t) => (document.getElementById('status').textContent = t || '');
      let activeSet = null, setsOfModule = [], questions = [], wrongList = [], onlyWrong = false;
      let examStartTs = null, examEndTs = null, lastScore = 0;
      let timerInterval = null, deadlineTs = null, hasSubmitted = false;
      const DEFAULT_TIME_LIMIT_MINUTES = 60;
      const timerEl = document.getElementById('timer');
      const moduleNameMap = {
        AR: 'AR KP',
        MK: 'MK 数学知识',
        WK: 'WK / PC 词汇与阅读',
        GS: 'GS 自然科学'
      };
      const historyPanel = document.getElementById('historyPanel');
      const viewHistoryBtn = document.getElementById('viewHistory');
      let historyVisible = false;
      let historyLoaded = false;

      async function showName() {
        const whoamiEl = document.getElementById('whoami');
        if (!whoamiEl) return;
        const stored = localStorage.getItem('asvab_student_name');
        const metaName = user.user_metadata?.full_name || (user.email ? user.email.split('@')[0] : '');
        studentName = stored || metaName || '未填写姓名';
        whoamiEl.textContent = `学员：${studentName}`;

        try {
          const { data: profile, error } = await supabase
            .from('profiles')
            .select('full_name')
            .eq('id', user.id)
            .maybeSingle();

          if (error) throw error;

          if (profile?.full_name) {
            studentName = profile.full_name;
            localStorage.setItem('asvab_student_name', studentName);
            whoamiEl.textContent = `学员：${studentName}`;
          }
        } catch (err) {
          console.warn('获取学员姓名失败：', err);
        }
      }
      await showName();

      document.getElementById('logout').onclick = async () => {
        await supabase.auth.signOut();
        location.href = 'auth.html';
      };

      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      }

      function formatDuration(ms) {
        const total = Math.max(0, Math.floor(ms / 1000));
        const mm = String(Math.floor(total / 60)).padStart(2, '0');
        const ss = String(total % 60).padStart(2, '0');
        return `${mm}:${ss}`;
      }
    

      function updateTimerDisplay() {
        if (!deadlineTs) {
        }
        const diff = deadlineTs - Date.now();
        if (diff <= 0) {
          timerEl.textContent = '剩余时间：00:00';
          stopTimer();
          submitQuiz(true);
        } else {
          timerEl.textContent = `剩余时间：${formatDuration(diff)}`;
        }
      }

      function startTimer(limitMinutes) {
        stopTimer();
        const parsed = Number(limitMinutes);
        if (!Number.isFinite(parsed) || parsed <= 0) {
          deadlineTs = null;
          timerEl.textContent = '';
          return;
        }

        const limitMs = parsed * 60 * 1000;
        deadlineTs = (examStartTs || Date.now()) + limitMs;
        updateTimerDisplay();
        timerInterval = setInterval(updateTimerDisplay, 1000);
      }

      const formatDateTime = (iso) => {
        if (!iso) return '-';
        const d = new Date(iso);
        if (Number.isNaN(d.getTime())) return '-';
        return d.toLocaleString();
      };

      const formatDurationText = (sec) => {
        if (!Number.isFinite(sec)) return '-';
        const total = Math.max(0, Math.floor(sec));
        const minutes = Math.floor(total / 60);
        const seconds = total % 60;
        if (minutes) {
          return `${minutes}分${seconds}秒`;
        }
        return `${seconds}秒`;
      };

      const refreshHistory = async (force = false) => {
        if (!historyPanel || !viewHistoryBtn) return;
        if (historyLoaded && !force) return;

        historyPanel.innerHTML = '<div class="small">正在加载成绩记录…</div>';
        try {
          viewHistoryBtn.disabled = true;
          const { data, error } = await supabase
            .from('results')
            .select('module,set_id,title,score,total,started_at,ended_at,duration_sec')
            .eq('user_id', user.id)
            .order('started_at', { ascending: false })
            .limit(100);

          if (error) throw error;

          historyLoaded = true;
          if (!data || !data.length) {
            historyPanel.innerHTML = '<div class="small">暂无成绩记录。</div>';
            return;
          }

          const rows = data
            .map((row, idx) => {
              const moduleLabel = moduleNameMap[row.module] || row.module || '-';
              const titleText = row.title || row.set_id || '';
              const scoreText = `${row.score ?? 0}/${row.total ?? 0}`;
              const durationText = formatDurationText(row.duration_sec);
              return `
                <tr>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${idx + 1}</td>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${escapeHtml(moduleLabel)}</td>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${escapeHtml(titleText)}</td>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${escapeHtml(scoreText)}</td>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${escapeHtml(durationText)}</td>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${escapeHtml(formatDateTime(row.started_at))}</td>
                  <td style="padding:8px 12px;border-bottom:1px solid #1f2937;">${escapeHtml(formatDateTime(row.ended_at))}</td>
                </tr>
              `;
            })
            .join('');

          historyPanel.innerHTML = `
            <div style="overflow:auto;">
              <table style="width:100%;border-collapse:collapse;min-width:640px;">
                <thead>
                  <tr style="background:#111827;">
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">序号</th>
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">科目</th>
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">套卷</th>
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">成绩</th>
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">耗时</th>
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">开始时间</th>
                    <th style="padding:8px 12px;text-align:left;border-bottom:1px solid #1f2937;">结束时间</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>
          `;
        } catch (err) {
          console.error('加载成绩记录失败：', err);
          historyPanel.innerHTML = `<div class="small" style="color:#f87171">加载失败：${escapeHtml(err.message || '未知错误')}</div>`;
        } finally {
          viewHistoryBtn.disabled = false;
        }
      };


      async function onLoadClick() {
        const btn = document.getElementById('load');
        const mod = document.getElementById('module').value;

        btn.disabled = true;
        btn.classList.add('is-loading');
        btn.textContent = '加载中…';
        setStatus('开始加载清单：/exams/manifest.json');

        try {
          const m = await fetch('exams/manifest.json?v=1', { cache: 'no-store' });
          if (!m.ok) throw new Error('manifest.json 加载失败：HTTP ' + m.status);
          const manifest = await m.json();

          if (!manifest[mod] || !manifest[mod].length) {
            throw new Error(`manifest 中没有科目 ${mod} 的套卷条目`);
          }
          setsOfModule = manifest[mod];
          activeSet = setsOfModule[0];

          setStatus(`找到套卷：${activeSet.title}，开始加载 ${activeSet.file}`);
          const s = await fetch(`${activeSet.file}?v=1`, { cache: 'no-store' });
          if (!s.ok) throw new Error(`套卷文件加载失败：HTTP ${s.status}（${activeSet.file}）`);
          const data = await s.json();
          if (!data || !Array.isArray(data.questions) || !data.questions.length) {
            throw new Error('套卷数据格式不正确或题目为空');
          }

          questions = data.questions.map((item) => {
            const qText = item.q || item.question || '';
            const choices = Array.isArray(item.choices)
              ? item.choices
              : Array.isArray(item.options)
              ? item.options
              : Array.isArray(item.c)
              ? item.c
              : [];
            if (!choices.length) {
              throw new Error('题目缺少选项，请联系管理员检查题库。');
            }
            const answer =
              typeof item.answer === 'number'
                ? item.answer
                : typeof item.a === 'number'
                ? item.a
                : 0;
            return {
              q: qText,
              choices,
              answer,
              explanation: item.explanation || item.e || ''
            };
          });

          const quizEl = document.getElementById('quiz');
          if (!quizEl) {
            throw new Error('页面缺少题目容器');
          }
          const html = questions
            .map((it, idx) => {
              const name = `q${idx}`;
              const choices = it.choices
                .map(
                  (t, i) => `
          <label style="display:block;margin:6px 0;">
            <input type="radio" name="${name}" value="${i}"> ${String.fromCharCode(65 + i)}. ${escapeHtml(t)}
          </label>`
                )
                .join('');
              return `
          <div class="card" data-idx="${idx}">
            <div style="font-weight:600;margin-bottom:6px;">${idx + 1}. ${escapeHtml(it.q)}</div>
            <div>${choices}</div>
            <div id="exp-${idx}" class="small" style="display:none;margin-top:8px;"></div>
          </div>`;
            })
            .join('');
          quizEl.innerHTML = html;

          const currentSetEl = document.getElementById('currentSet');
          if (currentSetEl) {
            currentSetEl.textContent = `当前套卷：${activeSet.title || activeSet.id || ''}`;
          }

          setStatus(`成功加载套卷：${activeSet.title || activeSet.id || ''}（共 ${questions.length} 题）`);

          wrongList = [];
          onlyWrong = false;
          document.getElementById('actions').style.display = 'flex';
          document.getElementById('result').style.display = 'none';
          const toggleWrongBtn = document.getElementById('toggleWrong');
          toggleWrongBtn.style.display = 'none';
          toggleWrongBtn.textContent = '只看错题';
          document.getElementById('exportWrong').style.display = 'none';
          const exportFullBtn = document.getElementById('exportFull');
          if (exportFullBtn) {
            exportFullBtn.style.display = questions.length ? 'inline-block' : 'none';
            exportFullBtn.disabled = false;
          }
          document.getElementById('submit').disabled = false;

          examStartTs = Date.now();
          examEndTs = null;
          lastScore = 0;
          hasSubmitted = false;

          const limit = activeSet?.timeLimitMinutes ?? DEFAULT_TIME_LIMIT_MINUTES;
          startTimer(limit);
        } catch (err) {
          console.error('加载套卷失败：', err);
          const message = err?.message || String(err);
          setStatus(`❌ 加载失败：${message}`);
          alert(`加载套卷失败：${message}`);
          questions = [];
          wrongList = [];
          onlyWrong = false;
          const quizEl = document.getElementById('quiz');
          if (quizEl) {
            quizEl.innerHTML = '';
          }
          const currentSetEl = document.getElementById('currentSet');
          if (currentSetEl) {
            currentSetEl.textContent = '';
          }
          document.getElementById('actions').style.display = 'none';
          document.getElementById('result').style.display = 'none';
        } finally {
          btn.disabled = false;
          btn.classList.remove('is-loading');
          btn.textContent = originalText;
        }
      }

      async function submitQuiz(auto = false) {
        if (hasSubmitted || !questions.length) return;
        hasSubmitted = true;
        stopTimer();
        deadlineTs = null;
        timerEl.textContent = '考试已结束';
        if (!examStartTs) examStartTs = Date.now();

        let score = 0;
        wrongList = [];
        questions.forEach((it, idx) => {
          const chosen = document.querySelector(`input[name="q${idx}"]:checked`);
          const userAns = chosen ? Number(chosen.value) : -1;
          const ok = userAns === it.answer;
          if (ok) {
            score += 1;
          } else {
            wrongList.push({ ...it, user: userAns });
          }
          const exp = document.getElementById(`exp-${idx}`);
          if (exp) {
            const correctLetter = String.fromCharCode(65 + (it.answer ?? 0));
            const userLetter = userAns >= 0 ? String.fromCharCode(65 + userAns) : '未作答';
            exp.style.display = 'block';
            exp.innerHTML = ok
              ? `✅ 正确：${correctLetter}。${escapeHtml(it.explanation || '')}`
              : `❌ 你的答案：${userLetter}；正确：${correctLetter}。${escapeHtml(it.explanation || '')}`;
          }
        });

        const r = document.getElementById('result');
        r.style.display = 'block';
        const end = new Date();
        examEndTs = end.getTime();
        lastScore = score;
        const durationSec = Math.max(0, Math.floor((examEndTs - examStartTs) / 1000));
        const durationText = `${Math.floor(durationSec / 60)}分${durationSec % 60}秒`;
        const header = `<div><b>得分：${score}/${questions.length}</b> · 正确率 ${(score / questions.length * 100).toFixed(0)}%</div>`;
        const meta = `<div class="small" style="margin-top:6px;">考试时间：${new Date(examStartTs).toLocaleString()} - ${end.toLocaleString()}（用时 ${durationText}）</div>`;
        r.innerHTML = header + meta + (auto ? '<div class="small" style="margin-top:6px;color:#facc15;">⏰ 时间到，系统已自动提交。</div>' : '');
        document.getElementById('toggleWrong').style.display = 'inline-block';
        document.getElementById('exportWrong').style.display = wrongList.length ? 'inline-block' : 'none';

        document.getElementById('submit').disabled = true;
        if (auto) setStatus('⏰ 时间已到，系统已自动提交。');

        const payload = {
          module: document.getElementById('module').value,

          set_id: activeSet?.id || 'set',
          title: activeSet?.title || '',
          score: lastScore,
          total: questions.length,

          started_at: new Date(examStartTs).toISOString(),
          ended_at: new Date(examEndTs).toISOString(),
          duration_sec: durationSec
        };
        const { error } = await supabase.from('results').insert({ user_id: user.id, ...payload });
        if (error) console.error('保存成绩失败：', error);

        historyLoaded = false;
        if (historyVisible) refreshHistory(true);
      }

      document.getElementById('submit').addEventListener('click', () => submitQuiz(false));

      document.getElementById('toggleWrong').addEventListener('click', () => {
        onlyWrong = !onlyWrong;
        questions.forEach((_, idx) => {
          const card = document.querySelector(`.card[data-idx="${idx}"]`);
          const isWrong = wrongList.some((w) => w.q === questions[idx].q);
          card.style.display = onlyWrong && !isWrong ? 'none' : 'block';
        });
        document.getElementById('toggleWrong').textContent = onlyWrong ? '显示全部' : '只看错题';
      });

      viewHistoryBtn?.addEventListener('click', async () => {
        historyVisible = !historyVisible;
        if (historyPanel) {
          historyPanel.style.display = historyVisible ? 'block' : 'none';
        }
        if (viewHistoryBtn) {
          viewHistoryBtn.textContent = historyVisible ? '收起成绩记录' : '查看成绩记录';
        }
        if (historyVisible) {
          await refreshHistory();
        }
      });

      const exportWrongBtn = document.getElementById('exportWrong');
      exportWrongBtn?.addEventListener('click', async () => {
        const btn = exportWrongBtn;
        if (!btn) return;
        const originalText = btn.textContent;
        btn.disabled = true;
        btn.textContent = '正在导出…';

        try {
          const ctx = await createPdfContext();
          notifyFontFallback(ctx.getFontError());

          const examTitle = activeSet?.title || 'ASVAB 模拟题';
          const examDate = examEndTs ? new Date(examEndTs) : new Date();
          ctx.addParagraph(`错题报告 - ${examTitle}`, { fontSize: 18, gap: 26 });
          ctx.addParagraph(`学员姓名：${studentName}`, { fontSize: 14 });
          ctx.addParagraph(`考试日期：${examDate.toLocaleDateString()} ${examDate.toLocaleTimeString()}`, { fontSize: 14 });
          ctx.addParagraph(`考试成绩：${lastScore}/${questions.length}`, { fontSize: 14, gap: 22 });

          if (!wrongList.length) {
            ctx.addParagraph('恭喜，本次全部答对，没有错题记录。');
          } else {
            wrongList.forEach((w, idx) => {
              const correct = String.fromCharCode(65 + (w.answer ?? 0));
              const userAns = w.user != null && w.user >= 0 ? String.fromCharCode(65 + w.user) : '未作答';
              ctx.addParagraph(`${idx + 1}. ${w.q}`, { fontSize: 13, gap: 20 });
              ctx.addParagraph(`正确答案：${correct}    我的答案：${userAns}`, { fontSize: 12 });
              if (w.explanation) {
                ctx.addParagraph(`解析：${w.explanation}`, { fontSize: 12 });
              }
              if (Array.isArray(w.choices) && w.choices.length) {
                w.choices.forEach((choice, cIdx) => {
                  const label = String.fromCharCode(65 + cIdx);
                  ctx.addParagraph(`${label}. ${choice}`, { fontSize: 11, gap: 16 });
                });
              }
              ctx.addSpacer(6);
            });
          }

          const fileDate = examDate.toISOString().slice(0, 10);
          ctx.save(`ASVAB_${activeSet?.id || 'set'}_错题_${fileDate}.pdf`);
        } catch (err) {
          console.error('导出错题 PDF 失败：', err);
          alert('导出错题 PDF 失败：' + (err.message || err.toString()));
        } finally {
          btn.disabled = false;
          btn.textContent = originalText;
        }
      });

      const exportFullBtn = document.getElementById('exportFull');
      exportFullBtn?.addEventListener('click', async () => {
        if (!questions.length) {
          alert('请先加载题目。');
          return;
        }
        const btn = exportFullBtn;
        const originalText = btn.textContent;
        btn.disabled = true;
        btn.textContent = '正在导出…';

        try {
          const ctx = await createPdfContext();
          notifyFontFallback(ctx.getFontError());

          const moduleCode = activeSet?.module || document.getElementById('module')?.value || '';
          const moduleLabel = moduleNameMap[moduleCode] || moduleCode || '科目';
          const examTitle = activeSet?.title || 'ASVAB 模拟题';
          const now = new Date();
          ctx.addParagraph(`ASVAB 模拟题 - ${examTitle}`, { fontSize: 18, gap: 26 });
          ctx.addParagraph(`科目：${moduleLabel}`, { fontSize: 14 });
          ctx.addParagraph(`题量：${questions.length} 题`, { fontSize: 14 });
          ctx.addParagraph(`导出时间：${now.toLocaleDateString()} ${now.toLocaleTimeString()}`, { fontSize: 14 });
          ctx.addParagraph(`学员姓名：${studentName}`, { fontSize: 14, gap: 22 });

          questions.forEach((q, idx) => {
            ctx.addParagraph(`${idx + 1}. ${q.q}`, { fontSize: 13, gap: 20 });
            if (Array.isArray(q.choices)) {
              q.choices.forEach((choice, cIdx) => {
                const label = String.fromCharCode(65 + cIdx);
                ctx.addParagraph(`${label}. ${choice}`, { fontSize: 12, gap: 16 });
              });
            }
            ctx.addSpacer(8);
          });

          ctx.addParagraph('答案与解析', { fontSize: 16, gap: 26 });
          questions.forEach((q, idx) => {
            const correct = String.fromCharCode(65 + (q.answer ?? 0));
            const explanationText = q.explanation ? `\n解析：${q.explanation}` : '';
            ctx.addParagraph(`[${idx + 1}] 正确答案：${correct}${explanationText}`, { fontSize: 12, gap: 18 });
          });

          const fileDate = now.toISOString().slice(0, 10);
          ctx.save(`ASVAB_${activeSet?.id || 'set'}_整套_${fileDate}.pdf`);
        } catch (err) {
          console.error('导出整套 PDF 失败：', err);
          alert('导出整套 PDF 失败：' + (err.message || err.toString()));
        } finally {
          btn.disabled = false;
          btn.textContent = originalText;
        }
      });

      document.getElementById('scrollTop')?.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      document.getElementById('scrollBottom')?.addEventListener('click', () => {
        const bodyHeight = Math.max(
          document.documentElement?.scrollHeight || 0,
          document.body?.scrollHeight || 0
        );
        window.scrollTo({ top: bodyHeight, behavior: 'smooth' });
      });

      document.getElementById('load').onclick = onLoadClick;
      window.onLoadClick = onLoadClick;
    }

    init().catch((err) => {
      console.error('初始化失败：', err);
      const statusEl = document.getElementById('status');
      if (statusEl) statusEl.textContent = '❌ 初始化失败：' + err.message;
      if (err.message !== 'Not signed in') {
        alert('页面初始化失败：' + err.message + '\n\n如果问题持续存在，请联系管理员。');
      }
    });
  </script>
</body>
</html>
